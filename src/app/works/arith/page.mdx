<div className="heading">
<a className="back" href="/">back</a>
  ## arithJS
  <span>Nov 2022</span>
</div>

<hr />

arith began as a CLI image compressor / decompressor that my friend Toby and I built in C for a [college class](https://github.com/yihui-hu/cs40). I subsequently ported the C code over to JavaScript so it could run on the web.

Feel free to play around with your own images [here](https://arith.vercel.app), or view the source code [here](https://github.com/yihui-hu/arith-js).

![image](https://yihui-work.s3.us-east-2.amazonaws.com/arith_desktop.webp)
![image](https://yihui-work.s3.us-east-2.amazonaws.com/arith_mobile.png)

## # Background

This project is an adaptation of my favourite assignment from one of the hardest computing classes I've taken so far at Tufts: _arith_, HW4 of [CS40](https://www.cs.tufts.edu/comp/40/).

We only programmed it for use as a command line interface (CLI), but I wanted to create a graphical user interface (GUI) for it. I wanted users to be able to see the original image versus its compressed and decompressed states. So I started researching ways to run C binary on the web, but...

## # Confusion

...I didn't get very far until I hit a few walls: cgi-bin? Apache? WebAssembly? I couldn't tackle the `"hello world"` of cgi scripting, let alone get the server running on my computer. So I said f` `k it, let me translate the C code into JavaScript code so that I can run it on the web<sup>1</sup> the only real roadblock I saw at the time was the bit manipulation in C that the (de)compression algorithm relies on.

Unfortunately, I was not aware of the following when I took the plunge:

- JavaScript does not have native support for extended ASCII characters, which is crucial for compressing the image without losing too much data.
  - When it tries to read in / write out integers with values > 127 as ASCII characters, a bunch of nonsensical characters appear
- JavaScript does not have integer types. No `uint_32t`s, no `unsigned` or `signed int`s – just numbers? What
- 0 is considered unsigned (I had to be extra careful when evaluating `val > 0`, `val >= 0` etc.)
- I expected as much, but I still find bitshifting in JavaScript to be super weird, so weird that it should probably just not be a thing.

## # Confusion Pt. 2 Electric Boogaloo

I had to be very clever with working around the differences between JavaScript and C. One idea I had to circumvent JavaScript's partial support for ASCII characters was to create my own custom encoding table in place of the extended ASCII character set.

They say Google is your best friend, but oddly enough this was one of those rare times when I couldn't find an answer to a question that I thought had already been asked a lot.

This is the native ASCII table for JavaScript, for reference:

```js
export const windows1252 = [
  0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0006, 0x0007, 0x0008,
  0x0009, 0x000a, 0x000b, 0x000c, 0x000d, 0x000e, 0x000f, 0x0010, 0x0011,
  0x0012, 0x0013, 0x0014, 0x0015, 0x0016, 0x0017, 0x0018, 0x0019, 0x001a,
  0x001b, 0x001c, 0x001d, 0x001e, 0x001f, 0x0020, 0x0021, 0x0022, 0x0023,
  0x0024, 0x0025, 0x0026, 0x0027, 0x0028, 0x0029, 0x002a, 0x002b, 0x002c,
  0x002d, 0x002e, 0x002f, 0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035,
  0x0036, 0x0037, 0x0038, 0x0039, 0x003a, 0x003b, 0x003c, 0x003d, 0x003e,
  0x003f, 0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047,
  0x0048, 0x0049, 0x004a, 0x004b, 0x004c, 0x004d, 0x004e, 0x004f, 0x0050,
  0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057, 0x0058, 0x0059,
  0x005a, 0x005b, 0x005c, 0x005d, 0x005e, 0x005f, 0x0060, 0x0061, 0x0062,
  0x0063, 0x0064, 0x0065, 0x0066, 0x0067, 0x0068, 0x0069, 0x006a, 0x006b,
  0x006c, 0x006d, 0x006e, 0x006f, 0x0070, 0x0071, 0x0072, 0x0073, 0x0074,
  0x0075, 0x0076, 0x0077, 0x0078, 0x0079, 0x007a, 0x007b, 0x007c, 0x007d,
  0x007e, 0x007f, 0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x0085, 0x0086,
  0x0087, 0x0088, 0x0089, 0x008a, 0x008b, 0x008c, 0x008d, 0x008e, 0x008f,
  0x0090, 0x0091, 0x0092, 0x0093, 0x0094, 0x0095, 0x0096, 0x0097, 0x0098,
  0x0099, 0x009a, 0x009b, 0x009c, 0x009d, 0x009e, 0x009f, 0x00a0, 0x00a1,
  0x00a2, 0x00a3, 0x00a4, 0x00a5, 0x00a6, 0x00a7, 0x00a8, 0x00a9, 0x00aa,
  0x00ab, 0x00ac, 0x00ad, 0x00ae, 0x00af, 0x00b0, 0x00b1, 0x00b2, 0x00b3,
  0x00b4, 0x00b5, 0x00b6, 0x00b7, 0x00b8, 0x00b9, 0x00ba, 0x00bb, 0x00bc,
  0x00bd, 0x00be, 0x00bf, 0x00c0, 0x00c1, 0x00c2, 0x00c3, 0x00c4, 0x00c5,
  0x00c6, 0x00c7, 0x00c8, 0x00c9, 0x00ca, 0x00cb, 0x00cc, 0x00cd, 0x00ce,
  0x00cf, 0x00d0, 0x00d1, 0x00d2, 0x00d3, 0x00d4, 0x00d5, 0x00d6, 0x00d7,
  0x00d8, 0x00d9, 0x00da, 0x00db, 0x00dc, 0x00dd, 0x00de, 0x00df, 0x00e0,
  0x00e1, 0x00e2, 0x00e3, 0x00e4, 0x00e5, 0x00e6, 0x00e7, 0x00e8, 0x00e9,
  0x00ea, 0x00eb, 0x00ec, 0x00ed, 0x00ee, 0x00ef, 0x00f0, 0x00f1, 0x00f2,
  0x00f3, 0x00f4, 0x00f5, 0x00f6, 0x00f7, 0x00f8, 0x00f9, 0x00fa, 0x00fb,
  0x00fc, 0x00fd, 0x00fe, 0x00ff,
];
```

Notice the `0xFFFD` entries? Those are ASCII characters that JavaScript can't read. So I replaced those entries with binary representations of [UTF-8 arrows](https://www.w3schools.com/charsets/ref_utf_arrows.asp):

```js
export const windows1252 = [
  0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0006, 0x0007, 0x0008,
  0x0009, 0x000a, 0x000b, 0x000c, 0x000d, 0x000e, 0x000f, 0x0010, 0x0011,
  0x0012, 0x0013, 0x0014, 0x0015, 0x0016, 0x0017, 0x0018, 0x0019, 0x001a,
  0x001b, 0x001c, 0x001d, 0x001e, 0x001f, 0x0020, 0x0021, 0x0022, 0x0023,
  0x0024, 0x0025, 0x0026, 0x0027, 0x0028, 0x0029, 0x002a, 0x002b, 0x002c,
  0x002d, 0x002e, 0x002f, 0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035,
  0x0036, 0x0037, 0x0038, 0x0039, 0x003a, 0x003b, 0x003c, 0x003d, 0x003e,
  0x003f, 0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047,
  0x0048, 0x0049, 0x004a, 0x004b, 0x004c, 0x004d, 0x004e, 0x004f, 0x0050,
  0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057, 0x0058, 0x0059,
  0x005a, 0x005b, 0x005c, 0x005d, 0x005e, 0x005f, 0x0060, 0x0061, 0x0062,
  0x0063, 0x0064, 0x0065, 0x0066, 0x0067, 0x0068, 0x0069, 0x006a, 0x006b,
  0x006c, 0x006d, 0x006e, 0x006f, 0x0070, 0x0071, 0x0072, 0x0073, 0x0074,
  0x0075, 0x0076, 0x0077, 0x0078, 0x0079, 0x007a, 0x007b, 0x007c, 0x007d,
  0x007e, 0x007f, 0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x0085, 0x0086,
  0x0087, 0x0088, 0x0089, 0x008a, 0x008b, 0x008c, 0x008d, 0x008e, 0x008f,
  0x0090, 0x0091, 0x0092, 0x0093, 0x0094, 0x0095, 0x0096, 0x0097, 0x0098,
  0x0099, 0x009a, 0x009b, 0x009c, 0x009d, 0x009e, 0x009f, 0x00a0, 0x00a1,
  0x00a2, 0x00a3, 0x00a4, 0x00a5, 0x00a6, 0x00a7, 0x00a8, 0x00a9, 0x00aa,
  0x00ab, 0x00ac, 0x00ad, 0x00ae, 0x00af, 0x00b0, 0x00b1, 0x00b2, 0x00b3,
  0x00b4, 0x00b5, 0x00b6, 0x00b7, 0x00b8, 0x00b9, 0x00ba, 0x00bb, 0x00bc,
  0x00bd, 0x00be, 0x00bf, 0x00c0, 0x00c1, 0x00c2, 0x00c3, 0x00c4, 0x00c5,
  0x00c6, 0x00c7, 0x00c8, 0x00c9, 0x00ca, 0x00cb, 0x00cc, 0x00cd, 0x00ce,
  0x00cf, 0x00d0, 0x00d1, 0x00d2, 0x00d3, 0x00d4, 0x00d5, 0x00d6, 0x00d7,
  0x00d8, 0x00d9, 0x00da, 0x00db, 0x00dc, 0x00dd, 0x00de, 0x00df, 0x00e0,
  0x00e1, 0x00e2, 0x00e3, 0x00e4, 0x00e5, 0x00e6, 0x00e7, 0x00e8, 0x00e9,
  0x00ea, 0x00eb, 0x00ec, 0x00ed, 0x00ee, 0x00ef, 0x00f0, 0x00f1, 0x00f2,
  0x00f3, 0x00f4, 0x00f5, 0x00f6, 0x00f7, 0x00f8, 0x00f9, 0x00fa, 0x00fb,
  0x00fc, 0x00fd, 0x00fe, 0x00ff,
];
```

With this, I could represent each red, blue and green pixel value as a corresponding character in the table to save space during compression.

## # Known oversights / issues / bugs of the program

- Currently expects a pretty much flawless/well-formed ppm file with the magic number of P6. Please don't add any # comments
- Outputs a P3 image instead of the original P6. I haven't attempted to print the RGB values out as ASCII characters because I'm scared the program will blow up<sup>2</sup>
- Doesn't work well with images with transparent backgrounds
- Will actually pass away on mobile if you give it a large enough .ppm image to (de)compress

## # Notes on optimization / performance

- Some of the characters in the custom encoding table take up 2 bytes (because they are beyond the 127 value of ASCII values which take up to 8 bits or 1 byte), which is not ideal for compression.
  - We want just 1 byte if possible, i.e. they must follow the `0x00**` format in hex.
- I expected the program in JavaScript to run slower than its C counterpart, but surprisingly it's also less efficient in terms of the actual image compression – 2.3mb vs 2.9mb for a 1500 x 1500px image. I'm just bad I guess

---

1. On hindsight, I would have looked more into WebAssembly. But I gave myself only the duration of Thanksgiving break to get this project done.
2. Towards the end of the project, I was exploring a way for it to _not_ blow up, which was to make a companion *de*coding table to make JavaScript print out extended ASCII characters. I didn't have time to implement it, but that's what I would try next.
